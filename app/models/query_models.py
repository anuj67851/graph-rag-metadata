from pydantic import BaseModel, Field
from typing import List, Optional
from .common_models import Subgraph # Import from common_models.py

class QueryRequest(BaseModel):
    """
    Represents the input for a user query to the backend.
    """
    query: str = Field(..., min_length=1, description="The natural language query from the user.")
    # Optional: session_id for chat history, user_id for personalization, etc.
    # session_id: Optional[str] = None

class ExtractedQueryEntity(BaseModel):
    """
    Represents an entity extracted from the user's query text by an LLM.
    """
    text: str = Field(..., description="The text of the entity as it appeared in the query.")
    # Optional: label (e.g. PERSON, ORG) if NER model provides it
    # label: Optional[str] = None

class QueryIntent(BaseModel):
    """
    Represents the classified intent of the user's query.
    Matches the structure from Feature 6 prompts (classify_query_intent).
    """
    query_intent: str = Field(..., description="The classified intent type (e.g., entity_information, relationship_discovery).")
    target_entities: List[str] = Field(default_factory=list, description="List of canonical entity names relevant to the intent.")
    intent_description: Optional[str] = Field(None, description="A brief explanation of the derived intent.")


class QueryResponse(BaseModel):
    """
    Represents the full response from the backend for a user query.
    This will be sent to the Streamlit UI.
    """
    llm_answer: str = Field(..., description="The final natural language answer generated by the LLM.")
    subgraph_context: Subgraph = Field(..., description="The subgraph data (nodes and edges) used as context for the LLM. For visualization.")
    llm_context_input_text: str = Field(..., description="The actual textual representation of the subgraph that was fed to the LLM.")
    # Optional fields for more transparency or debugging:
    # user_query: str
    # identified_query_entities: List[ExtractedQueryEntity]
    # classified_intent: QueryIntent
    # error_message: Optional[str] = None

if __name__ == "__main__":
    # Example Usage
    query_req = QueryRequest(query="Tell me about Project Nova and Alpha Corp.")
    print("--- Query Request ---")
    print(query_req.model_dump_json(indent=2))

    query_intent_example = QueryIntent(
        query_intent="relationship_discovery",
        target_entities=["Project Nova", "Alpha Corp"],
        intent_description="User wants to understand the connection between Project Nova and Alpha Corp."
    )
    print("\n--- Query Intent Example ---")
    print(query_intent_example.model_dump_json(indent=2))

    # Assume some Node and Edge objects are created as in common_models.py example
    node_pn = {"id": "Project Nova", "label": "Project Nova", "type": "PROJECT_NAME", "properties": {"desc": "A solar energy storage initiative"}}
    node_ac = {"id": "Alpha Corp", "label": "Alpha Corp", "type": "ORGANIZATION", "properties": {"desc": "Leader in sustainable energy"}}
    edge_dev = {"source": "Alpha Corp", "target": "Project Nova", "label": "DEVELOPED_BY", "properties":{}}

    # Need to convert dicts to Node/Edge Pydantic models if not already
    from .common_models import Node, Edge
    subgraph_data = Subgraph(
        nodes=[Node(**node_pn), Node(**node_ac)],
        edges=[Edge(**edge_dev)]
    )

    query_resp = QueryResponse(
        llm_answer="Project Nova is a solar energy storage initiative developed by Alpha Corp.",
        subgraph_context=subgraph_data,
        llm_context_input_text="Node: Project Nova (PROJECT_NAME) description: A solar energy storage initiative. Node: Alpha Corp (ORGANIZATION) description: Leader in sustainable energy. Relationship: Alpha Corp -[DEVELOPED_BY]-> Project Nova."
    )
    print("\n--- Query Response ---")
    print(query_resp.model_dump_json(indent=2))